<!--
Constitution Update Report
==========================
Version: v0.3.0 (aligned with project version)
Updated: 2025-11-17
Rationale: Update Part II to reflect v0.3.0 project state (9 entities, 45 rules, 10 SDM commands)

Key Changes:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Modified Principles (Part II ONLY):
‚Ä¢ Entity Clarity: Updated to 9 entities (added MarketingPlan, Analytics)
‚Ä¢ Validation Completeness: Updated to 45 validation rules (was 42)
‚Ä¢ Operation Semantics: Replaced 13 entity commands with 10 SDM workflow commands
‚Ä¢ Domain Fidelity: Updated marketing metrics and workflow patterns

Added Domain-Specific Guidance:
‚Ä¢ Marketing entity relationships (Project ‚Üí Products ‚Üí Campaigns ‚Üí Channels)
‚Ä¢ MCP-first tool integration strategy
‚Ä¢ Brand consistency validation rules
‚Ä¢ Marketing metrics validation (budget > 0, valid date ranges)

Part I and Part III:
‚úÖ UNCHANGED - Preserved exactly as generated by metaspec init
‚úÖ Part I remains generic meta-principles
‚úÖ Part III remains generic toolkit implementation principles

Impact:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Updated: 1 file (constitution.md Part II only)
Constitution Compliance: ‚úÖ Strictly followed command requirements
Command Adherence: ‚úÖ "Only update Part II. Preserve Part I and Part III exactly as they are."

Follow-up: Create domain specification with /metaspec.sds.specify

Generated by: /metaspec.sds.constitution
-->

# marketing-spec-kit Constitution

> Version 1.2.0 | Ratified: 2025-11-14 | Last Updated: 2025-11-15

---

## Part I: Project Core Values

**Purpose**: Foundational values that govern this spec-driven toolkit

### 1. AI-First Design

Every feature must be optimized for AI agent collaboration.

**Rules**:
- Clear error messages with examples
- Consistent naming conventions
- Explicit behavior (no magic defaults)
- All behavior documented

**Rationale**: AI agents need clear feedback to correct mistakes and learn patterns.

### 2. Progressive Enhancement

Ship minimal viable product first, iterate based on feedback.

**Rules**:
- Define MVP scope clearly
- Add features incrementally
- Maintain backward compatibility
- Document feature maturity (alpha, beta, stable)

**Rationale**: Start simple, grow based on real user needs.

### 3. Minimal Viable Abstraction

Avoid over-engineering. Keep it as simple as possible.

**Rules**:
- Start with concrete examples
- Abstract only after seeing 3+ similar patterns
- Each abstraction must add clear value
- Remove abstractions that don't earn their keep

**Rationale**: Complexity is the enemy of maintainability.

### 4. Domain Specificity

Focus on your domain. Generic toolkits are weak toolkits.

**Rules**:
- Research domain standards before designing
- Follow domain conventions and best practices
- Include domain-specific validation
- Don't force-fit generic solutions

**Rationale**: Domain focus creates real value for users.

<!-- Managed by /speckit.constitution -->

---

## Part II: Specification Design Principles

**Purpose**: Guidelines for defining Marketing Operations specifications (entities, validation rules, operations)

### 1. Entity Clarity

All marketing entity definitions must be complete and unambiguous.

**Marketing Operations Entities** (9 total):
- **Project**: Brand identity, voice, value propositions, target audience
- **Product**: Feature offerings, positioning, unique selling points
- **MarketingPlan**: Strategic planning, objectives, budget allocation, KPIs (NEW in v0.2.0)
- **Campaign**: Goals, strategies, metrics, timelines, budgets (plan_id REQUIRED)
- **Channel**: Platform type (social, email, blog), configuration, audiences
- **Tool**: MCP integration or REST API for task automation
- **ContentTemplate**: Brand guidelines, tone, style constraints
- **Milestone**: Version releases, launch events, community activities
- **Analytics**: Performance tracking, metrics, insights, optimization recommendations (NEW in v0.2.0)

**Rules**:
- All fields have explicit types and descriptions
- Required vs optional clearly specified (e.g., `brand_voice` required, `logo_url` optional)
- Examples provided for every entity
- Field naming follows marketing conventions (e.g., `target_audience`, `cpm`, `ctr`)

**Example** (Campaign entity):
```yaml
name: "MetaSpec v0.6.0 Launch"  # Required, string
goal: "awareness"  # Required, enum: awareness|consideration|conversion
target_audience: ["developers", "ai-engineers"]  # Required, list
budget: 500  # Required, number > 0
start_date: "2025-11-15"  # Required, ISO date
channels: ["twitter", "reddit"]  # Required, list of Channel IDs
```

**Rationale**: Clear entities enable AI agents to generate valid marketing specifications consistently.

### 2. Validation Completeness

All marketing constraints must be explicitly documented.

**Marketing-Specific Validation Rules**:
- **Budget Constraints**: `budget > 0`, reasonable ranges per channel
- **Date Validation**: `start_date < end_date`, no past dates for new campaigns
- **Brand Consistency**: `brand_voice` matches Project-level definition
- **Metrics Validation**: CTR/CPM/ROAS within industry benchmarks
- **Tool Availability**: Referenced Tools must exist and be configured
- **Channel Compatibility**: Content type matches channel capabilities

**Rules**:
- Document all validation rules in specification
- Specify error conditions clearly (e.g., "Budget must be positive number")
- Address edge cases (e.g., "What if Campaign has no Channels?")
- Validation rules traceable to marketing best practices

**Example Validation Rules**:
```yaml
Campaign.budget:
  - constraint: budget > 0
    error: "Campaign budget must be positive"
  - constraint: budget < 1000000
    warning: "Budget exceeds typical range, verify intentional"

Campaign.dates:
  - constraint: start_date < end_date
    error: "Campaign end date must be after start date"
  - constraint: start_date >= today
    error: "Cannot create campaign with past start date"
```

**Rationale**: Complete validation specs prevent invalid marketing specifications and guide AI corrections.

### 3. Operation Semantics

All marketing workflow commands (SDM Slash Commands) must have clear purposes and interfaces.

**SDM (Spec-Driven Marketing) Workflow Commands** (10 total):

**Core Workflow** (8):
- `/marketspec.constitution` - Establish marketing project principles
- `/marketspec.discover` - Identify business objectives and target audience
- `/marketspec.clarify` - Resolve ambiguities and refine requirements
- `/marketspec.strategy` - Design campaign structure and channel mix
- `/marketspec.checklist` - Validate completeness and quality
- `/marketspec.tasks` - Break down into actionable tasks
- `/marketspec.analyze` - Check specification consistency
- `/marketspec.create` - Generate validated YAML specification

**Extension Commands** (2):
- `/marketspec.review` - Analyze campaign performance vs. planned
- `/marketspec.optimize` - Generate optimization recommendations for next cycle

**Rules**:
- Command purpose clearly stated (guides user through workflow step)
- Input requirements specified (what user provides at this step)
- Output artifacts documented (what files/data are created)
- Quality criteria defined (how to verify step completion)
- Workflow position clear (which step comes before/after)

**Example Command Specification**:
```yaml
/marketspec.discover:
  purpose: "Identify business objectives, target audience, initial strategy"
  input:
    user_description: string  # Free-form business goals
    context: optional  # Project background, competitive landscape
  output:
    discovery_notes: markdown  # Structured interview results
    draft_entities: yaml  # Initial MarketingPlan + Campaign entities
  quality_criteria:
    - "1-5 objectives defined with priorities (P0/P1/P2)"
    - "Target audience segments identified"
    - "3-8 initial strategies outlined"
  workflow_position: "Step 2 of 10 (after constitution, before clarify)"
```

**Rationale**: Well-defined workflow commands enable AI agents to guide users through specification creation systematically.

### 4. Implementation Neutrality

Marketing specifications must not mandate specific technologies.

**Rules**:
- Focus on WHAT (campaign goals, content requirements), not HOW (implementation details)
- Platform-agnostic specifications (Twitter/X, Reddit, LinkedIn use same Channel schema)
- Multiple tool implementations possible (MCP tools, REST APIs, manual execution)
- Avoid technology-specific assumptions (e.g., don't hardcode "Twitter API v2", use generic "social_media" channel)

**Example** (Good - Implementation Neutral):
```yaml
Channel:
  type: "social_media"
  platform: "twitter"
  audiences: ["developers", "ai-enthusiasts"]
  content_types: ["short_text", "images", "links"]
```

**Example** (Bad - Too Technology-Specific):
```yaml
Channel:
  type: "twitter_api_v2"  # ‚ùå Couples to specific API version
  oauth_token: "..."  # ‚ùå Implementation detail
  rate_limit: 300  # ‚ùå Platform-specific constraint
```

**Rationale**: Technology-neutral specifications have longer lifespans and support multiple execution paths (MCP, API, manual).

### 5. Extensibility Design

Extension points must be clearly marked for marketing specification evolution.

**Extension Points**:
- **New Channel Types**: Add `video`, `podcast`, `webinar` channels without breaking existing specs
- **Custom Metrics**: Support custom KPIs beyond standard CTR/CPM/ROAS
- **New Content Types**: Add `video_script`, `podcast_outline` templates
- **Tool Plugins**: Add new MCP tools without schema changes

**Rules**:
- Extension points documented (e.g., `Channel.type` is extensible enum)
- Backward compatibility rules defined (e.g., old Campaign specs work with new Channel types)
- Versioning strategy specified (semantic versioning for spec schema)
- Deprecation process documented (e.g., 6-month notice before removing fields)

**Example** (Extensible Design):
```yaml
Channel:
  type: string  # Extensible: "social_media", "email", "blog", ... (add more later)
  platform: string  # Extensible: "twitter", "linkedin", ... (add more later)
  config: object  # Free-form config for platform-specific settings (extensible)
```

**Versioning Example**:
```yaml
spec_version: "0.3.0"  # MAJOR.MINOR.PATCH (0.x = development)
# 0.3.0: Complete SDM workflow system (10 commands)
# 0.2.0: Add MarketingPlan, Analytics entities (breaking: plan_id required)
# 0.1.0: Initial release (7 entities, 42 rules)
```

**Rationale**: Marketing needs evolve rapidly; specifications must support new channels, content types, and metrics without breaking changes.

### 6. Domain Fidelity

Respect marketing domain standards and conventions.

**Marketing Domain Standards**:
- **Metrics**: CTR (Click-Through Rate), CPM (Cost Per Mille), ROAS (Return on Ad Spend), CPC (Cost Per Click)
- **Campaign Types**: Awareness, Consideration, Conversion (marketing funnel stages)
- **Brand Voice**: Friendly, Professional, Technical, Casual (standard brand archetypes)
- **Content Formats**: Blog post (800-2000 words), Social post (280 chars), Email (subject + body)

**Authoritative Sources**:
- Marketing funnel: AIDA model (Attention, Interest, Desire, Action)
- Social media best practices: Platform-specific character limits, hashtag conventions
- Email marketing: CAN-SPAM compliance, unsubscribe requirements
- SEO standards: Meta descriptions (150-160 chars), title tags (50-60 chars)

**Rules**:
- Reference authoritative marketing sources (e.g., HubSpot, Content Marketing Institute)
- Use marketing terminology consistently (`campaign`, not `project`; `audience`, not `users`)
- Follow industry conventions (e.g., Twitter posts ‚â§280 chars, LinkedIn posts 1300-2000 chars optimal)
- Document domain constraints explicitly (e.g., "Budget must align with channel CPM rates")

**Example** (Domain-Faithful Campaign):
```yaml
Campaign:
  goal: "awareness"  # Standard funnel stage
  kpis:
    ctr: 0.05  # 5% CTR (industry average 2-5%)
    cpm: 10.0  # $10 CPM (typical social media range)
    roas: 3.0  # 3:1 ROAS (good performance)
  content_format: "short_text"  # Domain-standard format
  tone: "friendly"  # Standard brand voice archetype
```

**Rationale**: Domain-faithful specifications are intuitive for marketing professionals and follow industry best practices.

### 7. Workflow Completeness

All domain specifications must define a complete user workflow from start to finish.

**Marketing Operations Workflow Phases**:
1. **Strategic Planning**: Define marketing plan, objectives, budget, target audience
2. **Campaign Design**: Design campaigns aligned with plan objectives
3. **Content Creation**: Generate content assets for campaigns and channels
4. **Execution & Publishing**: Publish content to channels, start data collection
5. **Analytics & Optimization**: Track KPIs, generate reports, optimize based on data

**Rules**:
- **Phase Definition**: Each workflow phase must have clear purpose, entry/exit criteria
- **Operation Mapping**: All operations (Slash Commands) must map to specific workflow phases
- **Sequencing**: Document operation ordering and dependencies (e.g., "Plan before Campaign")
- **Decision Points**: Specify branching logic (e.g., "If KPI below target ‚Üí optimize, else ‚Üí next campaign")
- **Quality Gates**: Define checkpoints between phases (e.g., "Plan must be approved before Campaign design")
- **End-to-End Examples**: Provide workflow walkthroughs from planning to analytics

**Example** (Marketing Operations Workflow):
```yaml
Phase 1: Strategic Planning
  Purpose: Define marketing strategy and resource allocation
  Entry: Business goals defined, Project/Product specs ready
  Operations:
    - /marketing.plan.create: Create marketing plan
    - /marketing.plan.validate: Verify plan completeness
    - /marketing.plan.analyze: Get AI improvement suggestions
  Exit: Approved Plan with budget and KPIs
  Quality Gate: Plan status = "approved", KPIs defined

Phase 2: Campaign Design
  Purpose: Design campaigns to achieve Plan objectives
  Entry: Approved Plan exists
  Operations:
    - /marketing.campaign.design: AI-generate campaign suggestions
    - /marketing.campaign.create: Create campaign
  Exit: Campaigns linked to Plan, budget allocated
  Quality Gate: Campaign.budget ‚â§ Plan.remaining_budget

Phase 3: Content Creation
  Purpose: Generate marketing content for campaigns
  Entry: Campaign created, Channels configured
  Operations:
    - /marketing.content.plan: Generate content calendar
    - /marketing.generate.post: Create social media posts
    - /marketing.generate.article: Create blog articles
  Exit: Content assets ready for publishing
  Quality Gate: Content passes brand consistency check

Phase 4: Execution & Publishing
  Purpose: Publish content to channels
  Entry: Content ready, publish date reached
  Operations:
    - /marketing.execute.schedule: Schedule future publish
    - /marketing.execute.publish: Publish immediately
  Exit: Content live on channels, data tracking active
  Quality Gate: All scheduled content published successfully

Phase 5: Analytics & Optimization
  Purpose: Measure performance and optimize
  Entry: Campaign running ‚â•1 week, data available
  Operations:
    - /marketing.analytics.campaign: Analyze campaign KPIs
    - /marketing.analytics.plan: Analyze plan-level performance
    - /marketing.optimize.suggest: Get AI optimization recommendations
  Exit: Analytics report, optimization decisions
  Decision: If KPI met ‚Üí continue; if not ‚Üí optimize and retry
```

**Workflow Visualization**:
```
Plan ‚Üí Campaign ‚Üí Content ‚Üí Publish ‚Üí Analytics
  ‚Üë                                        ‚Üì
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Optimize (if needed) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Rationale**: 
- **User Guidance**: Users need clear paths through the toolkit, not just isolated commands
- **AI Assistance**: Workflow context helps AI guide users through correct operation sequences
- **Consistency**: Following MetaSpec's own design (SDS/SDD workflows are clearly defined)
- **Value**: "Workflow systems" are more valuable than "tool collections"

<!-- Managed by /metaspec.sds.constitution -->
<!-- Last updated: 2025-11-17 v0.3.0 - Updated entities (9), validation rules (45), SDM commands (10) -->

---

## Part III: Toolkit Implementation Principles

**Purpose**: Guidelines for building the marketing-spec-kit toolkit (parser, validator, CLI, slash commands)

### 1. Entity-First Design with Pydantic

Start with well-defined Pydantic models representing all 7 marketing entities.

**Implementation Approach**:
- Use **Pydantic v2.0+** for automatic validation and type safety
- Define entities in `src/marketing_spec_kit/models.py` with explicit field types
- Entity complexity: 5-10 fields per entity (avoid over-complexity)
- Use Field(...) for required fields with descriptions
- Use Optional[] for optional fields with sensible defaults
- Enums for constrained values (BrandVoice, CampaignGoal, ChannelType)

**Example Structure**:
```python
from pydantic import BaseModel, Field, HttpUrl
from typing import List, Optional

class Project(BaseModel):
    name: str = Field(..., description="Project name")
    tagline: str = Field(..., max_length=100)
    brand_voice: BrandVoice
    website: HttpUrl
    target_audience: List[str] = Field(..., min_items=1)
```

**Quality Targets**:
- All 7 entities defined: Project, Product, Campaign, Channel, Tool, ContentTemplate, Milestone
- 100% type coverage (mypy strict mode)
- All fields have descriptions

**Rationale**: Pydantic provides automatic JSON Schema generation, type validation, and clear error messages - perfect for AI agents.

### 2. Three-Layer Validator Architecture

Build a validator with clear separation: structural, semantic, and domain validation.

**Implementation Approach**:
- **Layer 1 (Structural)**: Pydantic handles automatically (types, required fields, constraints)
- **Layer 2 (Semantic)**: Custom rules in `MarketingSpecValidator.validate()` method
- **Layer 3 (Domain)**: Marketing-specific rules (budget > 0, ROAS ‚â• 3, CTR 0-1)

**Validation Strategy**:
```python
class MarketingSpecValidator:
    def validate(self, spec: MarketingSpec) -> ValidationResult:
        errors, warnings = [], []
        
        # VR-P01 to VR-P06: Project validation
        errors.extend(self._validate_project(spec.project))
        
        # VR-PR01 to VR-PR05: Product validation
        for product in spec.products:
            errors.extend(self._validate_product(product, spec))
        
        # ... other entities
        
        return ValidationResult(
            valid=(len(errors) == 0),
            errors=errors,
            warnings=warnings
        )
```

**Error Message Format**:
```python
{
    "code": "MKT-VAL-003",  # Consistent error codes
    "message": "Campaign budget must be greater than 0",
    "entity": "Campaign",
    "field": "budget",
    "value": 0,
    "fix": "Set budget to a positive number (e.g., budget: 5000)"
}
```

**Quality Targets**:
- All 25 validation rules implemented (VR-P01 to VR-M05)
- Performance: validate <200ms for typical spec
- 13 error codes with clear fix suggestions

**Rationale**: Layered validation separates concerns and enables extensibility. Clear error codes help AI agents fix issues.

### 3. Spec-First YAML/JSON Input

Users define marketing operations declaratively in YAML/JSON, toolkit validates and enables AI operations.

**Implementation Approach**:
- Primary format: **YAML** (human-readable, comment-friendly)
- Secondary format: **JSON** (API-friendly, tool integration)
- Parser in `src/marketing_spec_kit/parser.py` using PyYAML
- Programmatic API: accept dict for library usage

**Parsing Strategy**:
```python
class MarketingSpecParser:
    def parse(self, source: str | Path | dict) -> MarketingSpec:
        """Parse YAML/JSON/dict into MarketingSpec.
        
        Raises:
            ParseError: Invalid YAML/JSON syntax (MKT-VAL-001)
            ValidationError: Missing required fields (MKT-VAL-002)
        """
        if isinstance(source, dict):
            data = source
        elif isinstance(source, Path):
            with open(source) as f:
                data = yaml.safe_load(f)
        else:
            data = yaml.safe_load(source)
        
        return MarketingSpec.model_validate(data)
```

**Quality Targets**:
- Parse <100ms for typical spec
- Clear parse errors with line numbers (where possible)
- Support both file paths and string content

**Rationale**: YAML is approachable for non-developers, declarative format enables AI generation, version control friendly.

### 4. AI-Agent Slash Commands with Embedded Knowledge

13 slash commands embed specification knowledge for autonomous AI content generation.

**Implementation Approach**:
- Commands in `templates/custom/commands/` as Markdown files
- Each command embeds: entity schemas, validation rules, examples
- Frontmatter: description, argument-hint, allowed-tools, model
- Execution steps guide AI through workflow

**Command Template Structure**:
```markdown
---
description: "Retrieve project brand identity and guidelines"
argument-hint: "No arguments required - accesses project from spec"
allowed-tools: ["read_file"]
model: "claude-sonnet-4"
---

## Purpose
Access the Project entity to understand brand voice, target audience, and value propositions.

## Embedded Specification
[Full Project entity schema, validation rules VR-P01 to VR-P06, examples]

## Execution Steps
1. Load marketing specification from current directory
2. Extract project entity
3. Return formatted YAML with all project details
```

**Quality Targets**:
- 13 commands: 7 access + 4 generation + 2 execution
- P0 commands (8) for MVP: project, product, campaign, channel, tool, content_template, milestone, generate.post
- P1 commands (5) for future: generate.article/email/landing_page, execute.schedule/publish

**Naming Conventions**:
- Access: `marketing.{entity}` (e.g., marketing.project)
- Generation: `marketing.generate.{type}` (e.g., marketing.generate.post)
- Execution: `marketing.execute.{action}` (e.g., marketing.execute.publish)

**Rationale**: Embedded knowledge enables AI autonomy. Consistent naming helps AI discover commands. Side-effect warnings prevent destructive operations.

### 5. Progressive Enhancement: MVP to Full

Ship minimal viable toolkit first (parse + validate + init), add features incrementally.

**MVP Scope (v0.1.0 - Week 1-4)**:
- ‚úÖ Component 1: Parser (YAML/JSON ‚Üí Pydantic models)
- ‚úÖ Component 2: Validator (25 rules, clear errors)
- ‚úÖ Component 3: CLI (`init` and `validate` commands only)
- ‚úÖ Component 4: Slash Commands (8 P0 commands: 7 access + 1 post generation)

**Post-MVP (v0.2.0 - Week 5-6)**:
- ‚è≥ 5 P1 slash commands (3 generation + 2 execution)
- ‚è≥ Templates library (minimal, default, full)
- ‚è≥ Documentation and examples

**Future Enhancements (v0.3.0+)**:
- üîÆ CLI `generate` command (batch content generation)
- üîÆ CLI `report` command (campaign analytics)
- üîÆ Plugin system for custom validators
- üîÆ Template system for custom slash commands

**Versioning Strategy**:
- Semantic versioning (MAJOR.MINOR.PATCH)
- Maintain backward compatibility for MINOR/PATCH
- Document breaking changes clearly in CHANGELOG.md

**Rationale**: MVP validates core value proposition. Incremental delivery reduces risk. User feedback guides feature priority.

### 6. Test-Driven Development with 80%+ Coverage

Write tests before implementation. Tests are executable specifications.

**Testing Strategy**:
- **Unit tests** (`tests/unit/`): Component isolation
  - test_models.py: 10 tests (one per entity)
  - test_parser.py: 8 tests (valid YAML/JSON, invalid syntax, missing fields)
  - test_validator.py: 30 tests (25 validation rules + 5 edge cases)
  - test_cli.py: 10 tests (command execution, error handling)
  
- **Integration tests** (`tests/integration/`): End-to-end workflows
  - test_end_to_end.py: 5 tests (parse ‚Üí validate ‚Üí success/errors)
  - test_cli_integration.py: 5 tests (init ‚Üí edit ‚Üí validate workflow)

- **Fixtures** (`tests/fixtures/`): Test data
  - valid_specs/: minimal.yaml, full.yaml, metaspec_example.yaml
  - invalid_specs/: 25 YAML files (one per validation rule violation)

**Coverage Targets**:
- Overall: ‚â•80% line coverage
- Critical paths: 100% coverage (parser, validator core logic)
- Command: `pytest --cov=marketing_spec_kit --cov-report=term`

**CI/CD Integration**:
```yaml
# .github/workflows/test.yml
- name: Run tests
  run: |
    pytest --cov=marketing_spec_kit --cov-report=xml
    pytest --cov-report=term --cov-fail-under=80
```

**Rationale**: Tests catch regressions, enable refactoring, serve as documentation. 80% is industry standard for library code.

### 7. MCP-First Tool Integration

Prioritize Model Context Protocol (MCP) for marketing automation tool integration.

**Implementation Strategy**:
- **Tool entity** supports both MCP and REST API configurations
- MCP preferred for scheduling/publishing (mcp_config required if type=mcp)
- REST API fallback for legacy tools (api_config required if type=rest_api)
- Manual workflow always supported (users can copy/paste content)

**MCP Configuration Example**:
```yaml
tools:
  - id: twitter_publisher
    name: "Twitter MCP Publisher"
    type: mcp
    capabilities: ["schedule", "publish", "analyze"]
    mcp_config:
      server: "twitter-mcp"
      command: "npx -y @modelcontextprotocol/server-twitter"
      env:
        TWITTER_API_KEY: "${TWITTER_API_KEY}"
    status: active
```

**Validation Rules**:
- VR-T02: mcp_config required if type=mcp (error if missing)
- VR-T03: api_config required if type=rest_api (error if missing)
- VR-T05: api_config.base_url must use HTTPS (warning if HTTP)

**Slash Command Integration**:
- `marketing.execute.schedule` references tool.mcp_config
- `marketing.execute.publish` references tool.mcp_config
- Commands validate tool status=active before execution

**Rationale**: MCP enables seamless AI-driven marketing automation. Clear configuration prevents runtime errors. Multiple tool support ensures flexibility.

<!-- Managed by /metaspec.sdd.constitution -->

---

## Governance

### Amendment Process

**Part I (Project Core Values)**:
- Changes require project-wide review
- Breaking changes need major version bump
- Rationale must be documented

**Part II (Specification Design)**:
- Updated via `/metaspec.sds.constitution`
- Changes require minor version bump
- Consistency check with existing specs

**Part III (Toolkit Implementation)**:
- Updated via `/metaspec.sdd.constitution`
- Changes require minor version bump
- Consistency check with existing code

### Version Bump Rules

- **MAJOR**: Part I changes (core values modified)
- **MINOR**: Part II or Part III changes (new principles added)
- **PATCH**: Clarifications, examples, wording fixes

### Compliance

All specifications and code must follow this constitution. Use validation commands to check compliance:
- `/metaspec.sds.checklist` - Validate specification quality
- `/metaspec.sdd.checklist` - Validate toolkit implementation

---

**Constitution Version**: 1.2.0  
**Generated by**: MetaSpec 0.6.2  
**Domain**: Marketing Operations  
**Part III Updated**: 2025-11-15 by /metaspec.sdd.constitution
