# Implementation Specification: marketing-spec-kit

<!--
Toolkit: marketing-spec-kit
Version: 0.3.0
Language: Python 3.9+
Components: 5 (Parser, Validator, Generator, CLI, Slash Commands)
Domain Dependencies: 1 (domain/001-marketing-operations-spec v0.3.0)
Status: Draft

Impact:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Created: specs/toolkit/001-marketing-spec-kit-implementation/spec.md
Dependencies: domain/001-marketing-operations-spec v0.3.0 (9 entities, 45 rules, SDM workflow)
Related Files: README.md, AGENTS.md

Constitution Compliance: ✅ Entity-First, Spec-First, AI-Agent Friendly

Key Changes from v0.9.1:
- Generator: REMOVED → **RESTORED** (MetaSpec v0.9.2 Pattern Clarification)
- Generator correctly defined as: Creates PROJECT FILES (not domain content)
- Templates: 5 project templates (constitution, README, specs/, example)
- CLI Components: 5 (Parser, Validator, Generator, CLI, Slash Commands)

Next Steps:
1. Complete Parser implementation (85% done)
2. Complete Validator implementation (85% done)
3. Complete Generator implementation (70% done)
4. Update CLI init command to use Generator
5. Implement slash commands (100% done)

Generated by: /metaspec.sdd.specify (MetaSpec v0.9.2)
Regenerated: 2025-11-18 (Generator Pattern v0.9.2 - Specification Toolkit)
-->

---
toolkit_id: "001-marketing-spec-kit-implementation"
toolkit_version: "0.3.0"
toolkit_status: "draft"
primary_language: "python"
generated_by: "MetaSpec v0.9.2"
generated_date: "2025-11-18"
regenerated_reason: "Generator Pattern v0.9.2 - Specification Toolkit (creates project files)"
---

## Overview

**marketing-spec-kit** is a Python toolkit for parsing, validating, and managing marketing operation specifications based on the Marketing Operations Specification (`domain/001-marketing-operations-spec v0.3.0`).

**Toolkit Type**: Specification Toolkit (Generator/Scaffolder + Validator)

**Primary Use Cases**:
1. **Project Initialization**: Create marketing project structures with specifications
2. **Specification Parsing**: Parse YAML/JSON marketing specifications (9 entities)
3. **Specification Validation**: Enforce 45 validation rules
4. **AI-Driven Workflow**: Guide marketing specification creation (10 SDM commands)

**Core Components**:
- ✅ **Parser** - Parse YAML/JSON marketing specifications into Python objects
- ✅ **Validator** - Enforce 45 validation rules from domain specification
- ✅ **Generator** - Create marketing project structures from templates
- ✅ **CLI** - User commands (`init`, `validate`, `info`)
- ✅ **Slash Commands** - 10 SDM Workflow commands

**Future Enhancements** (Post-MVP):
- ⏭️ **SDK** - Programmatic API for other tools
- ⏭️ **Web UI** - Browser-based specification editor
- ⏭️ **IDE Extensions** - VS Code / Cursor integrations
- ⏭️ **Domain Application** - Separate tool that consumes specs to generate marketing content

---

## Components

### Component 1: Parser

#### Purpose
Parse YAML/JSON marketing specifications into validated Python objects (Pydantic models).

**Decision**: Parser is **CORE** because Use Case 2 explicitly requires parsing specifications.

#### Functionality (MVP)

**Entity Parsing**:
- Parse all 9 entity types from domain specification
- Support both YAML and JSON formats
- Handle nested structures and references
- Validate basic structure

**Supported Entities**:
1. Project - Brand identity and values
2. Product - Offerings and features
3. MarketingPlan - Strategic planning (NEW in v0.3.0)
4. Campaign - Marketing activities
5. Channel - Distribution platforms
6. Tool - MCP/API integrations
7. ContentTemplate - Brand guidelines
8. Milestone - Timeline markers
9. Analytics - Performance tracking (NEW in v0.3.0)

#### Architecture

**Model Layer** (`models.py`):
```python
from pydantic import BaseModel, Field

class Project(BaseModel):
    """Brand identity and values (8 fields)."""
    name: str = Field(..., description="Project name")
    tagline: str = Field(..., description="Project tagline")
    brand_voice: str = Field(..., description="Brand voice")
    # ... 5 more fields

class MarketingPlan(BaseModel):
    """Strategic marketing plan (11 fields)."""
    id: str = Field(..., description="Plan ID")
    name: str = Field(..., description="Plan name")
    project_id: str = Field(..., description="Project reference")
    objectives: list[dict] = Field(..., description="Plan objectives")
    # ... 7 more fields

class Campaign(BaseModel):
    """Marketing campaign (14 fields)."""
    id: str = Field(..., description="Campaign ID")
    name: str = Field(..., description="Campaign name")
    plan_id: str = Field(..., description="Plan reference (REQUIRED)")
    # ... 11 more fields

# ... 6 more entity models
```

**Parser Layer** (`parser.py`):
```python
import yaml
import json
from pathlib import Path
from typing import Union

class MarketingSpecParser:
    """Parse YAML/JSON marketing specifications."""
    
    def parse_file(self, file_path: Union[str, Path]) -> MarketingSpec:
        """Parse specification from file."""
        path = Path(file_path)
        
        if path.suffix in ('.yaml', '.yml'):
            data = yaml.safe_load(path.read_text())
        elif path.suffix == '.json':
            data = json.loads(path.read_text())
        else:
            raise UnsupportedFormatError(f"Unsupported format: {path.suffix}")
        
        return MarketingSpec(**data)
    
    def parse_string(self, content: str, format: str = 'yaml') -> MarketingSpec:
        """Parse specification from string."""
        if format == 'yaml':
            data = yaml.safe_load(content)
        elif format == 'json':
            data = json.loads(content)
        else:
            raise UnsupportedFormatError(f"Unsupported format: {format}")
        
        return MarketingSpec(**data)
```

#### Input
- **File path** (string): Path to YAML/JSON specification file
- **Format** (string, optional): 'yaml' or 'json' (auto-detected from extension)

#### Output
- **MarketingSpec** (object): Parsed specification with all entities
- **Errors** (list): Parse errors if invalid structure

#### CLI Integration
```bash
# Used internally by validate command
marketing_spec_kit validate campaign.yaml
```

#### Programmatic API
```python
from marketing_spec_kit.parser import MarketingSpecParser

parser = MarketingSpecParser()
spec = parser.parse_file("campaign.yaml")

print(f"Project: {spec.project.name}")
print(f"Campaigns: {len(spec.campaigns)}")
```

#### Error Handling
- Invalid YAML/JSON → `ParseError`
- Missing required fields → `SchemaError`
- Invalid entity types → `ValidationError`

#### Reference Implementation
See `src/marketing_spec_kit/parser.py` (Current: 85% complete)

---

### Component 2: Validator

#### Purpose
Enforce 45 validation rules from Marketing Operations Specification v0.3.0.

**Decision**: Validator is **CORE** because Use Case 3 explicitly requires validation.

#### Functionality (MVP)

**Validation Rules** (45 total):
- **Project Rules (VR-P01 to VR-P06)**: 6 rules
- **Product Rules (VR-PR01 to VR-PR05)**: 5 rules
- **MarketingPlan Rules (VR-MP01 to VR-MP10)**: 10 rules ⭐ NEW
- **Campaign Rules (VR-C01 to VR-C11)**: 11 rules
- **Channel Rules (VR-CH01 to VR-CH06)**: 6 rules
- **Tool Rules (VR-T01 to VR-T06)**: 6 rules
- **ContentTemplate Rules (VR-CT01 to VR-CT05)**: 5 rules
- **Milestone Rules (VR-M01 to VR-M05)**: 5 rules
- **Analytics Rules (VR-A01 to VR-A05)**: 5 rules ⭐ NEW

**Key Validations**:
- Cross-entity references (campaign.plan_id → marketing_plan.id)
- Budget constraints (campaign budgets ≤ plan total_budget)
- Date ranges (campaign dates within plan period)
- Required fields (plan_id mandatory for campaigns)
- Entity lifecycle states (draft → active → completed)

#### Architecture

```python
from typing import Optional
from dataclasses import dataclass

@dataclass
class ValidationIssue:
    """Single validation issue."""
    code: str  # e.g., "VR-C02"
    severity: str  # "error" or "warning"
    message: str
    entity_type: str
    entity_id: Optional[str]
    suggestion: Optional[str]

class MarketingSpecValidator:
    """Validate marketing specifications."""
    
    def validate(self, spec: MarketingSpec, strict: bool = False) -> ValidationResult:
        """Run all 45 validation rules."""
        errors = []
        warnings = []
        
        # Project validation (6 rules)
        errors.extend(self._validate_project(spec.project))
        
        # Product validation (5 rules)
        for product in spec.products:
            errors.extend(self._validate_product(product))
        
        # MarketingPlan validation (10 rules)
        for plan in spec.marketing_plans:
            errors.extend(self._validate_plan(plan, spec))
        
        # Campaign validation (11 rules)
        for campaign in spec.campaigns:
            errors.extend(self._validate_campaign(campaign, spec))
        
        # ... 5 more entity types
        
        if strict:
            errors.extend(warnings)
            warnings = []
        
        return ValidationResult(
            passed=len(errors) == 0,
            error_count=len(errors),
            warning_count=len(warnings),
            errors=errors,
            warnings=warnings
        )
    
    def _validate_campaign(self, campaign: Campaign, spec: MarketingSpec) -> list[ValidationIssue]:
        """Validate campaign entity (VR-C01 to VR-C11)."""
        issues = []
        
        # VR-C02: plan_id is REQUIRED
        if not campaign.plan_id:
            issues.append(ValidationIssue(
                code="VR-C02",
                severity="error",
                message="Campaign must reference a marketing plan",
                entity_type="campaign",
                entity_id=campaign.id,
                suggestion="Add 'plan_id' field referencing a MarketingPlan"
            ))
        
        # VR-C11: Campaign dates within plan period
        if campaign.plan_id:
            plan = spec.find_plan(campaign.plan_id)
            if plan:
                if campaign.start_date < plan.start_date:
                    issues.append(ValidationIssue(
                        code="VR-C11",
                        severity="error",
                        message=f"Campaign starts before plan period",
                        entity_type="campaign",
                        entity_id=campaign.id,
                        suggestion=f"Campaign start_date must be >= {plan.start_date}"
                    ))
        
        # ... 9 more campaign validation rules
        
        return issues
```

#### Input
- **MarketingSpec** (object): Parsed specification
- **strict** (bool, optional): Treat warnings as errors

#### Output
- **ValidationResult** (object): Validation results with errors/warnings
  - `passed` (bool): True if no errors
  - `error_count` (int): Number of errors
  - `warning_count` (int): Number of warnings
  - `errors` (list[ValidationIssue]): All errors
  - `warnings` (list[ValidationIssue]): All warnings

#### CLI Integration
```bash
# Basic validation
marketing_spec_kit validate campaign.yaml

# Strict mode (warnings as errors)
marketing_spec_kit validate campaign.yaml --strict

# Verbose output
marketing_spec_kit validate campaign.yaml --verbose

# JSON output
marketing_spec_kit validate campaign.yaml --format json
```

#### Programmatic API
```python
from marketing_spec_kit.validator import MarketingSpecValidator

validator = MarketingSpecValidator()
result = validator.validate(spec, strict=True)

if result.passed:
    print("✓ Validation passed")
else:
    for error in result.errors:
        print(f"{error.code}: {error.message}")
        if error.suggestion:
            print(f"  → {error.suggestion}")
```

#### Error Handling
- Invalid entity references → `ValidationIssue` with code
- Budget violations → `ValidationIssue` with suggested fix
- Date conflicts → `ValidationIssue` with date constraints

#### Reference Implementation
See `src/marketing_spec_kit/validator.py` (Current: 85% complete)

---

### Component 3: Generator

#### Purpose
Generate complete marketing project structures from templates.

**Decision**: Generator is **CORE** because:
- Toolkit type is "Specification Toolkit" (manages specifications)
- Primary use case requires project initialization
- init command requires structured project generation
- Users need standardized project structure

**Generation Targets** (Project files, NOT domain content):
- **Project structure**: Create `memory/`, `specs/` directories
- **Constitution**: Generate `memory/constitution.md` from principles template
- **README**: Create project README with toolkit usage guide
- **Example spec**: Render example campaign specification (optional)
- **Git configuration**: Create `.gitignore` for project

#### Architecture

**Generator Layer** (`generator.py`):
```python
from pathlib import Path
from typing import Any
from jinja2 import Environment, PackageLoader
from datetime import datetime

class MarketingProjectGenerator:
    """Generate complete marketing project structures from templates."""
    
    def __init__(self, custom_template_dir: Path | None = None):
        """Initialize generator with Jinja2 environment."""
        loader = (FileSystemLoader(str(custom_template_dir)) 
                 if custom_template_dir 
                 else PackageLoader("marketing_spec_kit", "project_templates"))
        
        self.env = Environment(
            loader=loader,
            trim_blocks=True,
            lstrip_blocks=True,
            keep_trailing_newline=True,
        )
    
    def generate_project(
        self,
        project_name: str,
        output_dir: Path,
        template: str = "default",
        force: bool = False,
        dry_run: bool = False,
    ) -> dict[str, Any]:
        """Generate a complete marketing project from template."""
        
        # Step 1: Validate output directory
        if not dry_run and output_dir.exists() and not force:
            raise FileExistsError(
                f"Output directory already exists: {output_dir}\n"
                "Use --force flag to overwrite."
            )
        
        # Step 2: Create template context
        context = self._create_context(project_name, template)
        
        # Step 3: Select files based on template type
        files_to_generate = self._select_files(template)
        
        # Step 4: Render templates
        rendered_files = {}
        for rel_path, template_name in files_to_generate.items():
            rendered_files[rel_path] = self._render_template(
                template_name, context
            )
        
        # Step 5: Write files (unless dry_run)
        if not dry_run:
            self._write_files(output_dir, rendered_files, force)
        
        return {
            "project_name": project_name,
            "output_dir": str(output_dir),
            "template": template,
            "files": list(rendered_files.keys()),
            "file_count": len(rendered_files),
        }
    
    def _select_files(self, template: str) -> dict[str, str]:
        """Select files to generate based on template type."""
        # Minimal: Only essential files
        files = {
            "memory/constitution.md": "constitution.md.j2",
            "specs/.gitkeep": "gitkeep.j2",
            "README.md": "readme.md.j2",
            ".gitignore": "gitignore.j2",
        }
        
        # Default: Add example specification
        if template == "default":
            files["specs/example-campaign.yaml"] = "example-spec.yaml.j2"
        
        return files
```

#### Templates

**Location**: `src/marketing_spec_kit/project_templates/`

**Required Templates** (5 total):
1. **constitution.md.j2** - Project principles and constraints
2. **readme.md.j2** - Project README with quickstart guide
3. **gitignore.j2** - Git ignore rules
4. **gitkeep.j2** - Keep empty specs/ directory in git
5. **example-spec.yaml.j2** - Example campaign specification (optional)

**Template Variables**:
- `{{ project_name }}` - Name of the project
- `{{ generated_date }}` - Date of generation
- `{{ toolkit_name }}` - "marketing-spec-kit"
- `{{ toolkit_version }}` - "0.3.0"

#### Input
- **project_name** (string): Name for the new project
- **output_dir** (Path): Output directory path
- **template** (string): `minimal` or `default`
- **force** (bool): Overwrite existing directory
- **dry_run** (bool): Only return structure without writing

#### Output
- **Complete project directory**: All files and subdirectories
- **Generation report**: Dictionary with file count and paths
- **Success indicator**: Boolean status

#### Generated Project Structure

**Minimal template** (4 files):
```
my-marketing-project/
├── memory/
│   └── constitution.md    # Project principles
├── specs/
│   └── .gitkeep          # Keep directory in git
├── README.md             # Project documentation
└── .gitignore            # Git ignore rules
```

**Default template** (5 files):
```
my-marketing-project/
├── memory/
│   └── constitution.md
├── specs/
│   ├── .gitkeep
│   └── example-campaign.yaml  # Example specification
├── README.md
└── .gitignore
```

#### CLI Integration
```bash
# Create minimal project
marketing_spec_kit init my-project --template minimal

# Create default project (with example)
marketing_spec_kit init my-project

# Force overwrite existing
marketing_spec_kit init my-project --force

# Dry run (preview only)
marketing_spec_kit init my-project --dry-run
```

#### Programmatic API
```python
from marketing_spec_kit.generator import MarketingProjectGenerator
from pathlib import Path

generator = MarketingProjectGenerator()

result = generator.generate_project(
    project_name="my-marketing-project",
    output_dir=Path("./my-marketing-project"),
    template="default"
)

print(f"✓ Generated {result['file_count']} files")
for file_path in result['files']:
    print(f"  - {file_path}")
```

#### Error Handling
- Output directory exists → `FileExistsError` (unless --force)
- Template not found → `TemplateNotFoundError`
- Template rendering error → `TemplateRenderError`
- File write error → `IOError`

#### Reference Implementation
See `src/marketing_spec_kit/generator.py` (Current: 70% complete)

---

### Component 4: CLI

#### Purpose
Provide command-line interface for users to interact with the toolkit.

**Decision**: CLI is **CORE** because all primary use cases require user commands.

#### Functionality (MVP)

**Commands**:

1. **`init`** - Initialize new marketing project
   - Argument: `<project-name>` (required) - Project directory name
   - Options:
     - `--template TEXT` - Template type (minimal, default) [default: default]
     - `--force` - Overwrite existing directory
     - `--dry-run` - Preview without creating files
   - Example: `marketing_spec_kit init my-project --template default`

2. **`validate`** - Validate marketing specification
   - Argument: `<filename>` (required) - Specification file path
   - Options:
     - `--strict` - Treat warnings as errors
     - `--verbose` - Show detailed validation info
     - `--format TEXT` - Output format (text, json) [default: text]
     - `--quiet` - Only show pass/fail
   - Example: `marketing_spec_kit validate campaign.yaml --strict`

3. **`info`** - Show toolkit information
   - No arguments
   - Example: `marketing_spec_kit info`

#### Architecture

```python
import typer
from rich.console import Console
from pathlib import Path

app = typer.Typer()
console = Console()

@app.command()
def init(
    project_name: str = typer.Argument(..., help="Project directory name"),
    template: str = typer.Option(
        "default", "--template", "-t", help="Template type (minimal, default)"
    ),
    force: bool = typer.Option(
        False, "--force", "-f", help="Overwrite existing directory"
    ),
    dry_run: bool = typer.Option(
        False, "--dry-run", help="Preview without creating files"
    ),
):
    """Initialize a new marketing project with proper structure."""
    from marketing_spec_kit.generator import MarketingProjectGenerator
    
    output_dir = Path.cwd() / project_name
    generator = MarketingProjectGenerator()
    
    try:
        result = generator.generate_project(
            project_name=project_name,
            output_dir=output_dir,
            template=template,
            force=force,
            dry_run=dry_run,
        )
        
        if dry_run:
            console.print("[cyan]Dry run - would create:[/cyan]")
        else:
            console.print("[green]✓[/green] Created marketing project:")
        
        for file_path in result['files']:
            console.print(f"  - {file_path}")
        
        console.print(f"\n[cyan]→[/cyan] Total: {result['file_count']} files")
        
        if not dry_run:
            console.print(f"\n[green]Next steps:[/green]")
            console.print(f"  cd {project_name}")
            console.print("  # Edit memory/constitution.md with your principles")
            console.print("  # Create specs in specs/ directory")
            console.print("  marketing_spec_kit validate specs/your-spec.yaml")
    
    except FileExistsError as e:
        console.print(f"[red]✗[/red] {e}", err=True)
        raise typer.Exit(1)
    except Exception as e:
        console.print(f"[red]✗[/red] Unexpected error: {e}", err=True)
        raise typer.Exit(2)

@app.command()
def validate(
    filename: str = typer.Argument(..., help="Specification file to validate"),
    strict: bool = typer.Option(False, "--strict", "-s", help="Treat warnings as errors"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Show detailed validation info"),
    format: str = typer.Option("text", "--format", "-f", help="Output format: text or json"),
    quiet: bool = typer.Option(False, "--quiet", "-q", help="Only show pass/fail"),
):
    """Validate a marketing specification file."""
    # Implementation in current cli.py
    pass

@app.command()
def info():
    """Show marketing-spec-kit information."""
    # Implementation in current cli.py
    pass
```

#### Input
- **Command-line arguments** from user
- **Options/flags** for command customization

#### Output
- **Rich formatted text** to console
- **JSON output** for automation (when --format json)
- **Exit codes**: 0 (success), 1 (validation error), 2 (unexpected error)

#### CLI Integration
This IS the CLI component

#### Programmatic API
Not applicable (CLI is user-facing only)

#### Error Handling
- Invalid arguments → Show usage help
- File not found → Clear error message
- Validation errors → Formatted error list with suggestions
- Unexpected errors → Error message + exit code 2

#### Reference Implementation
See `src/marketing_spec_kit/cli.py` (Current: 90% complete)

---

### Component 5: Slash Commands

#### Purpose
Provide AI-driven workflow guidance for creating marketing specifications.

**Decision**: Slash Commands are **CORE** because Use Case 4 requires AI workflow guidance.

#### Functionality (MVP)

**Command Set** (10 commands):

1. `/marketspec.constitution` - Establish project principles
2. `/marketspec.discover` - Identify business objectives
3. `/marketspec.clarify` - Resolve ambiguities
4. `/marketspec.strategy` - Design campaign structure
5. `/marketspec.checklist` - Validate completeness
6. `/marketspec.tasks` - Break down into actions
7. `/marketspec.analyze` - Check consistency
8. `/marketspec.create` - Generate YAML specification
9. `/marketspec.review` - Collect execution feedback
10. `/marketspec.optimize` - Generate improvements

**Workflow Flow**:
```
Core Flow:      constitution → discover → strategy → create
Quality Gates:             ↓ clarify ↓   ↓ checklist  ↓ analyze
Post-Execution:  execute campaign → review → optimize → [next cycle]
```

#### Architecture

**Location**: `templates/sdm/commands/`

Each command is a Markdown file with:
- Command description
- Input requirements
- Output format (which entities to create)
- Quality criteria
- Example output

```markdown
# /marketspec.constitution

## Purpose
Establish core principles and constraints for marketing operations.

## Input Requirements
- Project name
- Business context
- Marketing constraints
- Brand values

## Output Format
Generate `memory/constitution.md` with:
- Core Principles
- Prohibited Patterns
- Required Patterns
- Quality Standards

## Example Output
...
```

#### Input
- **User context** from AI conversation
- **Project state** from previous commands

#### Output
- **Guidance text** for AI agent
- **YAML/Markdown snippets** to include in specification
- **Next steps** recommendations

#### CLI Integration
Not directly integrated (used by AI agents in conversation)

#### Programmatic API
```python
# AI agents access via template files
from pathlib import Path

commands_dir = Path("templates/sdm/commands")
command_content = (commands_dir / "marketspec.constitution.md").read_text()
```

#### Error Handling
Not applicable (static template files)

#### Reference Implementation
See `templates/sdm/commands/*.md` (Current: 100% complete)

---

## Dependencies

### External Dependencies

**Core Runtime**:
- Python 3.9+
- pydantic ^2.0 (entity models, validation)
- pyyaml ^6.0 (YAML parsing)
- typer ^0.20.0 (CLI framework)
- rich ^14.0.0 (CLI output formatting)
- jinja2 ^3.1.0 (template rendering for Generator)

**Development**:
- pytest ^8.0 (testing framework)
- pytest-cov ^4.0 (coverage reporting)
- ruff ^0.1.0 (linting)
- mypy ^1.8 (type checking)

### Domain Dependencies

**Marketing Operations Specification** v0.3.0:
- Location: `specs/domain/001-marketing-operations-spec/spec.md`
- Entities: 9 (Project, Product, MarketingPlan, Campaign, Channel, Tool, ContentTemplate, Milestone, Analytics)
- Validation Rules: 45
- Workflows: 1 (SDM - 10 commands)

---

## File Structure

```
marketing-spec-kit/
├── src/
│   └── marketing_spec_kit/
│       ├── __init__.py              # Package init, version
│       ├── models.py                # 9 Pydantic entity models
│       ├── parser.py                # YAML/JSON parser
│       ├── validator.py             # 45 validation rules
│       ├── generator.py             # Project generator ⭐ NEW
│       ├── cli.py                   # CLI commands (typer)
│       ├── exceptions.py            # Custom exceptions
│       ├── __main__.py              # CLI entry point
│       └── project_templates/       # Generator templates ⭐ NEW
│           ├── constitution.md.j2
│           ├── readme.md.j2
│           ├── gitignore.j2
│           ├── gitkeep.j2
│           └── example-spec.yaml.j2
│
├── templates/
│   └── sdm/
│       ├── README.md                # SDM workflow documentation
│       └── commands/                # 10 slash command files ✅
│
├── tests/
│   ├── test_parser.py               # Parser tests (9 entities)
│   ├── test_validator.py            # Validator tests (45 rules)
│   ├── test_generator.py            # Generator tests ⭐ NEW
│   ├── test_cli.py                  # CLI tests
│   └── fixtures/                    # Test YAML files
│
├── examples/
│   ├── complete-example.yaml        # Full example (9 entities)
│   ├── minimal-example.yaml         # Minimal example
│   └── sdm-workflow-example.md      # SDM workflow walkthrough
│
├── pyproject.toml                   # Project config
├── README.md                        # User documentation
├── AGENTS.md                        # AI agent guidance
└── CHANGELOG.md                     # Version history
```

---

## Acceptance Criteria

### Core Components (MVP)

- ✅ **Parser**: Parse all 9 entity types from YAML/JSON
- ✅ **Validator**: Implement all 45 validation rules
- ✅ **Generator**: Generate project structures from templates ⭐ NEW
- ✅ **CLI**: `info`, `init`, `validate` commands
- ✅ **Slash Commands**: 10 SDM workflow commands
- ✅ **Project Init**: Create complete AGENTS.md-compliant structure

### Quality Metrics

- ✅ Test coverage ≥90%
- ✅ All 45 validation rules tested
- ✅ Generator templates tested ⭐ NEW
- ✅ CLI commands functional
- ✅ Type hints complete (mypy passes)

### Documentation

- ✅ README with quickstart guide
- ✅ AGENTS.md with slash commands
- ✅ CLI help messages complete
- ✅ Example specifications
- ✅ Template documentation ⭐ NEW

---

## Implementation Notes

### Generator Pattern Compliance

✅ **Correct Pattern** (MetaSpec v0.9.2):
- Generator creates **PROJECT FILES** (constitution, README, specs/)
- NOT domain content (social posts, blog articles, campaigns)
- Templates are **PROJECT STRUCTURE** templates
- Follows MetaSpec's own generator implementation

❌ **Anti-Pattern** (Avoided):
- Generating marketing content (that's a separate Domain Application)
- Mixing toolkit and domain responsibilities
- Creating deliverables instead of specifications

### Component Status

| Component | Status | Coverage | Notes |
|-----------|--------|----------|-------|
| Parser | 85% | 88% | Missing JSON format tests |
| Validator | 85% | 92% | Missing 3 cross-entity rules |
| Generator | 70% | 0% | Newly restored, needs tests ⭐ |
| CLI | 90% | 75% | init needs Generator integration |
| Slash Commands | 100% | N/A | Static templates complete |

---

**Generated by**: MetaSpec v0.9.2 (Specification Toolkit Pattern)  
**Generation Date**: 2025-11-18  
**Template**: /metaspec.sdd.specify (Generator Pattern v0.9.2)
