"""
CLI for marketing_spec_kit - Marketing Operations Specification Toolkit

Commands:
- init: Create a new specification from template
- validate: Validate an existing specification
- info: Show toolkit information
"""

import sys
from pathlib import Path

import typer
from rich.console import Console
from rich.panel import Panel
from rich.table import Table

from marketing_spec_kit import __version__
from marketing_spec_kit.exceptions import (
    MarketingSpecError,
    ParseError,
    ValidationError,
)
from marketing_spec_kit.parser import MarketingSpecParser
from marketing_spec_kit.validator import MarketingSpecValidator

app = typer.Typer(
    name="marketing_spec_kit",
    help="Marketing Operations Specification Toolkit",
    no_args_is_help=True,
    add_completion=False,
)
console = Console()


@app.command()
def info():
    """Show toolkit information"""
    console.print(Panel.fit(
        f"[bold cyan]marketing-spec-kit[/bold cyan] [dim]v{__version__}[/dim]\n\n"
        "[yellow]Marketing Operations Specification Toolkit[/yellow]\n\n"
        "Domain: [green]Marketing Operations[/green]\n"
        "Entities: [green]9[/green] (Project, Product, MarketingPlan, Campaign, Channel, Tool, Template, Milestone, Analytics)\n"
        "Validation Rules: [green]45[/green]\n"
        "SDM Commands: [green]10[/green] (constitution ‚Üí discover ‚Üí ... ‚Üí optimize)\n"
        "CLI Commands: [green]init, validate, info[/green]",
        title="üì¶ Toolkit Info",
        border_style="cyan",
    ))

    console.print("\n[bold]Available Commands:[/bold]")
    console.print("  [cyan]init[/cyan] <project-dir>  Initialize a new marketing project with complete structure")
    console.print("  [cyan]validate[/cyan] <filename>  Validate an existing specification")
    console.print("  [cyan]info[/cyan]                 Show this information")


@app.command()
def init(
    project_name: str = typer.Argument(..., help="Project directory name (e.g., my-marketing-project)"),
    template: str = typer.Option(
        "default",
        "--template",
        "-t",
        help="Template to use: minimal or default",
    ),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Overwrite existing directory",
    ),
    dry_run: bool = typer.Option(
        False,
        "--dry-run",
        help="Preview without creating files",
    ),
):
    """Initialize a new marketing project with complete structure
    
    Creates a standard project layout following MetaSpec v0.9.5 guidelines:
    - .marketingspeckit/    AI assistant commands (10 slash commands)
    - memory/               Project principles (constitution.md)
    - specs/                Workflow guidance (README.md - NOT spec templates)
    - README.md             Project documentation
    - .gitignore            Git ignore rules
    
    Note: Specifications are generated by AI through interactive dialogue,
    not by filling in pre-defined templates. See specs/README.md for workflow.
    
    Templates:
    - minimal: Essential infrastructure (4 files + 10 commands)
    - default: Same as minimal (unified approach per MetaSpec v0.9.5)
    
    Example:
        marketing_spec_kit init my-marketing-project
        marketing_spec_kit init my-marketing-project --dry-run
    """
    from marketing_spec_kit.generator import MarketingProjectGenerator

    try:
        output_dir = Path.cwd() / project_name
        generator = MarketingProjectGenerator()

        if not dry_run:
            console.print("[cyan]‚Üí[/cyan] Creating project structure...")
        else:
            console.print("[cyan]‚Üí[/cyan] Dry run - would create...")

        result = generator.generate_project(
            project_name=project_name,
            output_dir=output_dir,
            template=template,
            force=force,
            dry_run=dry_run,
        )

        # Display created files
        console.print()
        for file_path in result['files']:
            console.print(f"  [green]‚úì[/green] {file_path}")

        console.print(f"\n[cyan]‚Üí[/cyan] Total: {result['file_count']} files")

        if not dry_run:
            console.print("\n[green]‚úì[/green] Marketing project created successfully!")
            console.print("\n[bold]Next steps:[/bold]")
            console.print(f"  1. cd {project_name}")
            console.print("  2. Edit [cyan]memory/constitution.md[/cyan] to define your marketing principles")
            console.print("  3. Read [cyan]specs/README.md[/cyan] to understand the AI-driven workflow")
            console.print("  4. Use AI to generate specifications (see specs/README.md)")
            console.print("     Example: [dim]\"Create a Q1 email campaign specification\"[/dim]")
            console.print("  5. AI will generate [cyan]specs/001-xxx/spec.yaml[/cyan]")
            console.print("  6. Validate: [cyan]marketing_spec_kit validate specs/001-xxx/spec.yaml[/cyan]")

    except FileExistsError as e:
        console.print(f"[red]‚úó[/red] {e}")
        raise typer.Exit(1)
    except Exception as e:
        console.print(f"[red]‚úó[/red] Unexpected error: {e}")
        if "--verbose" in sys.argv:
            import traceback
            console.print(traceback.format_exc())
        raise typer.Exit(2)


@app.command()
def validate(
    filename: str = typer.Argument(..., help="Specification file to validate (YAML or JSON)"),
    strict: bool = typer.Option(
        False,
        "--strict",
        "-s",
        help="Fail on warnings (treat warnings as errors)",
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Show detailed validation info",
    ),
    format: str = typer.Option(
        "text",
        "--format",
        "-f",
        help="Output format: text or json",
    ),
    quiet: bool = typer.Option(
        False,
        "--quiet",
        "-q",
        help="Only show pass/fail (minimal output)",
    ),
):
    """Validate a marketing specification
    
    Checks:
    - YAML/JSON syntax
    - Required fields
    - 42 validation rules (VR-P01 to VR-M05)
    - Reference integrity (product_ids, channel_ids, etc.)
    
    Example:
        marketing_spec_kit validate my-spec.yaml
        marketing_spec_kit validate my-spec.yaml --strict
        marketing_spec_kit validate my-spec.yaml --format json
        marketing_spec_kit validate my-spec.yaml --quiet
    
    Exit codes:
        0: Validation passed
        1: Validation failed (errors found)
        2: Parse error (invalid YAML/JSON)
    """
    try:
        # Validate format option
        if format not in ["text", "json"]:
            console.print(f"[red]‚úó[/red] Invalid format: {format} (use 'text' or 'json')")
            raise typer.Exit(1)

        # Check if file exists
        spec_path = Path(filename)
        if not spec_path.exists():
            if format == "json":
                import json
                print(json.dumps({"error": "File not found", "file": filename}))
        elif quiet:
            console.print("[red]‚úó[/red] FAIL (file not found)")
        else:
            console.print(f"[red]‚úó[/red] File '{filename}' not found")
            raise typer.Exit(2)

        # Parse specification
        if not quiet and format == "text":
            console.print(f"[cyan]‚Üí[/cyan] Parsing '{filename}'...")

        parser = MarketingSpecParser()

        try:
            spec = parser.parse(spec_path)
            if not quiet and format == "text":
                console.print("[green]‚úì[/green] Parsing successful")
        except (ParseError, ValidationError) as e:
            if format == "json":
                import json
                error_data = {
                    "error": "parse_error",
                    "code": e.code,
                    "message": e.message,
                    "file": filename,
                }
                if hasattr(e, 'fix') and e.fix:
                    error_data["fix"] = e.fix
                if hasattr(e, 'line') and e.line:
                    error_data["line"] = e.line
                print(json.dumps(error_data, indent=2))
            elif quiet:
                console.print("[red]‚úó[/red] FAIL (parse error)")
            else:
                console.print(f"[red]‚úó[/red] Parsing failed: [{e.code}] {e.message}")
                if hasattr(e, 'fix') and e.fix:
                    console.print(f"  [yellow]Fix:[/yellow] {e.fix}")
                if hasattr(e, 'line') and e.line:
                    console.print(f"  [dim]Line {e.line}[/dim]")
            raise typer.Exit(2)

        # Validate specification
        if not quiet and format == "text":
            console.print("[cyan]‚Üí[/cyan] Validating specification...")

        validator = MarketingSpecValidator()
        result = validator.validate(spec)

        # Display results based on format
        if format == "json":
            _display_validation_result_json(result, filename)
        elif quiet:
            # Quiet mode: minimal output
            if result.valid and not (strict and result.warning_count > 0):
                console.print("[green]‚úì[/green] PASS")
            else:
                console.print("[red]‚úó[/red] FAIL")
        else:
            # Normal text output
            console.print()
        _display_validation_result(result, verbose)

        # Exit code
        if not result.valid:
            if not quiet and format == "text":
                console.print("\n[red bold]‚úó Validation failed![/red bold]")
            raise typer.Exit(1)
        elif strict and result.warning_count > 0:
            if not quiet and format == "text":
                console.print("\n[yellow]‚ö†[/yellow] Warnings present (strict mode enabled)")
            raise typer.Exit(1)
        else:
            if not quiet and format == "text":
                console.print("\n[green bold]‚úì Validation successful![/green bold]")
            raise typer.Exit(0)

    except typer.Exit:
        # Re-raise typer.Exit without catching
        raise
    except MarketingSpecError:
        # Already handled above
        raise typer.Exit(1)
    except Exception as e:
        if format == "json":
            import json
            print(json.dumps({"error": "unexpected_error", "message": str(e)}))
        else:
            console.print(f"[red]‚úó[/red] Unexpected error: {e}")
            if verbose:
                import traceback
                console.print(traceback.format_exc())
            raise typer.Exit(1)


def _display_validation_result(result, verbose: bool = False):
    """Display validation results with rich formatting"""

    # Summary panel
    summary_lines = [
        f"Rules Checked: [cyan]{result.rules_checked}[/cyan]",
        f"Rules Passed: [green]{result.rules_passed}[/green]",
        f"Success Rate: [{'green' if result.success_rate >= 90 else 'yellow'}]{result.success_rate:.1f}%[/]",
    ]

    if result.error_count > 0:
        summary_lines.append(f"Errors: [red]{result.error_count}[/red]")
    if result.warning_count > 0:
        summary_lines.append(f"Warnings: [yellow]{result.warning_count}[/yellow]")
    if verbose and len(result.info) > 0:
        summary_lines.append(f"Info: [blue]{len(result.info)}[/blue]")

    console.print(Panel(
        "\n".join(summary_lines),
        title="üìä Validation Summary",
        border_style="cyan" if result.valid else "red",
    ))

    # Errors table
    if result.error_count > 0:
        console.print()
        errors_table = Table(title="‚ùå Errors", border_style="red", show_lines=True)
        errors_table.add_column("Code", style="red bold")
        errors_table.add_column("Entity", style="cyan")
        errors_table.add_column("Field", style="yellow")
        errors_table.add_column("Message", style="white")
        errors_table.add_column("Fix", style="green")

        for err in result.errors:
            errors_table.add_row(
                err.code,
                f"{err.entity_type}\n[dim]{err.entity_id}[/dim]" if err.entity_id else err.entity_type,
                err.field,
                err.message,
                err.fix,
            )

        console.print(errors_table)

    # Warnings table
    if result.warning_count > 0:
        console.print()
        warnings_table = Table(title="‚ö†Ô∏è  Warnings", border_style="yellow")
        warnings_table.add_column("Code", style="yellow bold")
        warnings_table.add_column("Entity", style="cyan")
        warnings_table.add_column("Message", style="white")
        warnings_table.add_column("Suggestion", style="green dim")

        for warn in result.warnings:
            warnings_table.add_row(
                warn.code,
                f"{warn.entity_type}\n[dim]{warn.entity_id}[/dim]" if warn.entity_id else warn.entity_type,
                warn.message,
                warn.fix,
            )

        console.print(warnings_table)

    # Info (verbose only)
    if verbose and len(result.info) > 0:
        console.print()
        info_table = Table(title="‚ÑπÔ∏è  Info", border_style="blue")
        info_table.add_column("Code", style="blue bold")
        info_table.add_column("Entity", style="cyan")
        info_table.add_column("Message", style="white")

        for info in result.info:
            info_table.add_row(
                info.code,
                f"{info.entity_type}\n[dim]{info.entity_id}[/dim]" if info.entity_id else info.entity_type,
                info.message,
            )

        console.print(info_table)


def _display_validation_result_json(result, filename: str):
    """Display validation results in JSON format"""
    import json

    output = {
        "file": filename,
        "valid": result.valid,
        "summary": {
            "rules_checked": result.rules_checked,
            "rules_passed": result.rules_passed,
            "success_rate": round(result.success_rate, 1),
            "error_count": result.error_count,
            "warning_count": result.warning_count,
        },
        "errors": [],
        "warnings": [],
    }

    # Add errors
    for err in result.errors:
        output["errors"].append({
            "code": err.code,
            "entity_type": err.entity_type,
            "entity_id": err.entity_id,
            "field": err.field,
            "message": err.message,
            "fix": err.fix,
        })

    # Add warnings
    for warn in result.warnings:
        output["warnings"].append({
            "code": warn.code,
            "entity_type": warn.entity_type,
            "entity_id": warn.entity_id,
            "message": warn.message,
            "fix": warn.fix,
        })

    # Print JSON
    print(json.dumps(output, indent=2))


def main():
    """Main entry point."""
    app()


if __name__ == "__main__":
    main()
